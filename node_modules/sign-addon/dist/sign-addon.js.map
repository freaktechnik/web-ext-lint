{"version":3,"sources":["webpack://sign-addon/external \"mz\"","webpack://sign-addon/external \"fs\"","webpack://sign-addon/external \"url\"","webpack://sign-addon/external \"path\"","webpack://sign-addon/external \"deepcopy\"","webpack://sign-addon/external \"jsonwebtoken\"","webpack://sign-addon/external \"request\"","webpack://sign-addon/external \"common-tags\"","webpack://sign-addon/./src/amo-client.js","webpack://sign-addon/./src/PseudoProgress.js","webpack://sign-addon/./src/index.js","webpack://sign-addon/webpack/bootstrap","webpack://sign-addon/webpack/startup","webpack://sign-addon/webpack/runtime/compat get default export","webpack://sign-addon/webpack/runtime/define property getters","webpack://sign-addon/webpack/runtime/hasOwnProperty shorthand"],"names":["require","formatResponse","response","overrides","options","_stringifyToJson","JSON","stringify","maxLength","prettyResponse","e","length","substring","toString","Client","constructor","apiKey","apiSecret","apiUrlPrefix","apiJwtExpiresIn","debugLogging","statusCheckInterval","statusCheckTimeout","logger","console","downloadDir","process","cwd","fs","defaultFs","request","defaultRequest","proxyServer","requestConfig","progressBar","this","_progressBar","_clearInterval","clearInterval","_setInterval","setInterval","preamble","stdout","interval","motionCounter","bucket","emptyBucketPointers","setPreamble","addendum","shellWidth","isTTY","Number","columns","bucketSize","i","push","animate","animateConfig","conf","speed","bucketIsFull","moveBucket","randomlyFillBucket","finish","fillBucket","write","randomIndex","Math","floor","random","showBucket","isFull","newPointers","forEach","pointer","map","join","_fs","_request","sign","guid","version","channel","xpiPath","formData","upload","createReadStream","addonUrl","httpMethod","put","encodeURIComponent","debug","post","warn","bind","url","throwOnBadResponse","then","httpResponse","body","receivedError","error","indexOf","statusCode","Promise","resolve","success","id","downloadedFiles","errorCode","errorDetails","Error","absoluteURL","headers","waitForSignedAddon","statusUrl","_clearTimeout","clearTimeout","_setAbortTimeout","setTimeout","_setStatusCheckTimeout","lastStatus","reject","abortTimeout","oneLine","checkSignedStatus","async","status","get","canBeAutoSigned","automated_signing","signedAndReady","valid","active","reviewed","files","requiresManualReview","log","result","downloadSignedFiles","err","checkValidationStatus","processed","validation_url","signedFiles","createWriteStream","allDownloads","dataExpected","dataReceived","showProgress","progress","amount","toFixed","padding","Array","download","fileUrl","fileName","path","absUrl","split","out","configureRequest","method","followRedirect","on","contentLength","parseInt","chunk","pipe","foundUnsignedFiles","file","signed","download_url","all","replace","requestConf","patch","delete","urlString","match","config","jwt","defaultJwt","String","proxy","authToken","iss","algorithm","expiresIn","timeout","Authorization","Accept","toLowerCase","toUpperCase","requestMethod","responseBody","parse","redact","obj","hdr","Object","keys","key","args","prototype","call","arguments","val","newVal","deepcopy","signAddon","verbose","apiProxy","apiRequestConfig","AMOClient","DefaultAMOClient","reportEmpty","name","isFile","statError","signAddonAndExit","systemProcess","throwError","exit","stack","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","prop","hasOwnProperty"],"mappings":"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","file":"sign-addon.js","sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = require(\"mz\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"url\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"deepcopy\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"jsonwebtoken\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"request\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"common-tags\");;","/* eslint max-classes-per-file: 0 */\nimport defaultFs from 'fs';\nimport url from 'url';\nimport path from 'path';\n\nimport deepcopy from 'deepcopy';\nimport defaultJwt from 'jsonwebtoken';\nimport defaultRequest from 'request';\nimport { oneLine } from 'common-tags';\n\nimport PseudoProgress from './PseudoProgress';\n\n/** @typedef {import(\"request\").OptionsWithUrl} RequestConfig */\n\n/** @typedef {import(\"request\").Response} Response */\n\n/**\n * @typedef {\"listed\" | \"unlisted\"} ReleaseChannel\n */\n\n/**\n * See: https://addons-server.readthedocs.io/en/latest/topics/api/signing.html#checking-the-status-of-your-upload\n *\n * @typedef {{\n *   guid: string,\n *   active: boolean,\n *   automated_signing: boolean,\n *   files: File[],\n *   passed_review: boolean,\n *   pk: string,\n *   processed: boolean,\n *   reviewed: boolean,\n *   url: string,\n *   valid: boolean,\n *   validation_results: object,\n *   validation_url: string,\n *   version: string,\n * }} SigningStatus\n */\n\n/**\n * @typedef {object} ClientParams\n * @property {string} apiKey - API key string from the Developer Hub\n * @property {string} apiSecret - API secret string from the Developer Hub\n * @property {string} apiUrlPrefix - API URL prefix, including any leading paths\n * @property {number=} apiJwtExpiresIn - Number of seconds until the JWT token for the API request expires. This must match the expiration time that the API server accepts\n * @property {boolean=} debugLogging - When true, log more information\n * @property {number=} statusCheckInterval - A period in millesconds between checks when waiting on add-on status\n * @property {number=} statusCheckTimeout -  A length in millesconds to give up if the add-on hasn't been validated and signed\n * @property {typeof console=} logger\n * @property {string=} downloadDir - Absolute path to save downloaded files to. The working directory will be used by default\n * @property {typeof defaultFs=} fs\n * @property {typeof defaultRequest=} request\n * @property {string=} proxyServer - Optional proxy server to use for all requests, such as \"http://yourproxy:6000\"\n * @property {RequestConfig=} requestConfig - Optional configuration object to pass to request(). Not all parameters are guaranteed to be applied\n * @property {PseudoProgress=} progressBar\n */\n\n/**\n * @typedef {object} SignParams\n * @property {string=} guid - optional add-on GUID (ID in install.rdf)\n * @property {string} version - add-on version string\n * @property {ReleaseChannel=} channel - release channel (listed or unlisted)\n * @property {string} xpiPath - path to xpi file\n */\n\n/**\n * @typedef {(\"SERVER_FAILURE\"|\"ADDON_NOT_AUTO_SIGNED\"|\"VALIDATION_FAILED\")} SignErrorCode\n */\n\n/**\n * @typedef {{\n *   success: boolean,\n *   id: string | null,\n *   downloadedFiles: string[] | null,\n *   errorCode: SignErrorCode | null,\n *   errorDetails: string | null\n * }} SignResult\n */\n\n/**\n * Returns a nicely formatted HTTP response.\n * This makes the response suitable for logging.\n *\n * @param {string|object} response - either the response's body or an object representing a JSON API response.\n * @param {object=} overrides\n * @returns {string}\n */\nexport function formatResponse(response, overrides = {}) {\n  const options = {\n    _stringifyToJson: JSON.stringify,\n    maxLength: 500,\n    ...overrides,\n  };\n  let prettyResponse = response;\n  const stringify = options._stringifyToJson || JSON.stringify;\n  if (typeof prettyResponse === 'object') {\n    try {\n      prettyResponse = stringify(prettyResponse);\n    } catch (e) {\n      //\n    }\n  }\n  if (typeof prettyResponse === 'string') {\n    if (prettyResponse.length > options.maxLength) {\n      prettyResponse = `${prettyResponse.substring(0, options.maxLength)}...`;\n    }\n  }\n  return prettyResponse.toString();\n}\n\n/**\n * Returns the basename of a URL, suitable for saving to disk.\n *\n * @param {string} absUrl\n * @returns {string}\n */\nexport function getUrlBasename(absUrl) {\n  // TODO: `url.parse()` might return `undefined` so we need to check that first.\n  // @ts-ignore\n  const urlPath = path.basename(url.parse(absUrl).path);\n  const parts = urlPath.split('?');\n\n  return parts[0];\n}\n/**\n * addons.mozilla.org API client.\n */\nexport class Client {\n  /**\n   * Type for `this.request()`.\n   *\n   * @typedef {object} RequestMethodOptions\n   * @property {boolean=} throwOnBadResponse - if true, an error will be thrown when response status is not 2xx\n   */\n\n  /**\n   * Type for `this.request()`.\n   *\n   * @typedef {Promise<[Response, SigningStatus]>} RequestMethodReturnValue\n   */\n\n  /**\n   * See: https://addons-server.readthedocs.io/en/latest/topics/api/signing.html#get--api-v4-addons-(string-guid)-versions-(string-version)-[uploads-(string-upload-pk)-]\n   *\n   * @typedef {{ signed: boolean, download_url: string, hash: string }} File\n   */\n\n  /**\n   * @param {ClientParams} params\n   */\n  constructor({\n    apiKey,\n    apiSecret,\n    apiUrlPrefix,\n    // TODO: put this back to something sane after we\n    // address the file upload issue on AMO:\n    // https://github.com/mozilla/addons-server/issues/3688\n    apiJwtExpiresIn = 60 * 5, // 5 minutes\n    debugLogging = false,\n    statusCheckInterval = 1000,\n    statusCheckTimeout = 900000, // 15 minutes.\n    logger = console,\n    downloadDir = process.cwd(),\n    fs = defaultFs,\n    request = defaultRequest,\n    proxyServer,\n    requestConfig,\n    progressBar,\n  }) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.apiUrlPrefix = apiUrlPrefix; // default set in CLI options.\n    this.apiJwtExpiresIn = apiJwtExpiresIn;\n    this.statusCheckInterval = statusCheckInterval;\n    this.statusCheckTimeout = statusCheckTimeout;\n    this.debugLogging = debugLogging;\n    this.logger = logger;\n    this.downloadDir = downloadDir;\n    this.proxyServer = proxyServer;\n    this.requestConfig = requestConfig || {};\n\n    // Set up external dependencies, allowing for overrides.\n    this._progressBar =\n      progressBar ||\n      new PseudoProgress({\n        preamble: 'Validating add-on',\n      });\n    this._fs = fs;\n    this._request = request;\n  }\n\n  /**\n   * Sign a new version of your add-on at addons.mozilla.org.\n   *\n   * @param {SignParams} signParams\n   * @returns {Promise<SignResult>}\n   */\n  sign({ guid, version, channel, xpiPath }) {\n    /**\n     * @type {{\n     *   upload: defaultFs.ReadStream;\n     *   channel?: string;\n     *   version?: string;\n     * }}\n     */\n    const formData = {\n      upload: this._fs.createReadStream(xpiPath),\n    };\n    let addonUrl = '/addons/';\n    let httpMethod = this.put;\n    if (guid) {\n      // PUT to a specific URL for this add-on + version.\n      addonUrl += `${encodeURIComponent(guid)}/versions/${encodeURIComponent(\n        version,\n      )}/`;\n      if (channel) {\n        formData.channel = channel;\n      }\n    } else {\n      // POST to a generic URL to create a new add-on.\n      this.debug('Signing add-on without an ID');\n      httpMethod = this.post;\n      formData.version = version;\n      if (channel) {\n        this.logger.warn(\n          'Specifying a channel for a new add-on is unsupported. ' +\n            'New add-ons are always in the unlisted channel.',\n        );\n      }\n    }\n\n    return httpMethod\n      .bind(this)(\n        {\n          url: addonUrl,\n          formData,\n        },\n        {\n          throwOnBadResponse: false,\n        },\n      )\n      .then(\n        /**\n         * @param {[\n         *   Response,\n         *   { error?: string, headers?: {[name: string]: string}, url: string }\n         * ]} requestValue\n         * @returns {Promise<SignResult>} result\n         */\n        ([httpResponse, body]) => {\n          const response = body;\n\n          const acceptableStatuses = [200, 201, 202];\n          const receivedError = !!response.error;\n          if (\n            acceptableStatuses.indexOf(httpResponse.statusCode) === -1 ||\n            receivedError\n          ) {\n            if (response.error) {\n              this.logger.error(\n                `Server response: ${response.error}`,\n                `(status: ${httpResponse.statusCode})`,\n              );\n              return Promise.resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'SERVER_FAILURE',\n                errorDetails: response.error,\n              });\n            }\n\n            throw new Error(\n              `Received bad response from the server while requesting ${this.absoluteURL(\n                addonUrl,\n              )}\\n\\n` +\n                `status: ${httpResponse.statusCode}\\n` +\n                `response: ${formatResponse(response)}\\n` +\n                `headers: ${JSON.stringify(httpResponse.headers || {})}\\n`,\n            );\n          }\n\n          return this.waitForSignedAddon(response.url);\n        },\n      );\n  }\n\n  /**\n   * Poll a status URL, waiting for the queued add-on to be signed.\n   *\n   * @typedef {object} WaitForSignedAddonParams\n   * @property {typeof clearTimeout=} _clearTimeout\n   * @property {typeof setTimeout=} _setAbortTimeout\n   * @property {typeof setTimeout=} _setStatusCheckTimeout\n   *\n   * @param {string} statusUrl - URL to GET for add-on status\n   * @param {WaitForSignedAddonParams} options\n   * @returns {Promise<SignResult>}\n   */\n  waitForSignedAddon(\n    statusUrl,\n    {\n      _clearTimeout = clearTimeout,\n      _setAbortTimeout = setTimeout,\n      _setStatusCheckTimeout = setTimeout,\n    } = {},\n  ) {\n    /** @type {SigningStatus=} */\n    let lastStatus;\n\n    return new Promise((resolve, reject) => {\n      /** @type {NodeJS.Timer} */\n      let statusCheckTimeout;\n\n      /** @type {NodeJS.Timer} */\n      const abortTimeout = _setAbortTimeout(() => {\n        this._progressBar.finish();\n        _clearTimeout(statusCheckTimeout);\n\n        reject(\n          new Error(oneLine`Signing took too long to complete; last status:\n            ${formatResponse(lastStatus || '[null]')}`),\n        );\n      }, this.statusCheckTimeout);\n\n      // This function polls the API until the add-on is signed or requires\n      // manual review. If the add-on is signed, we download the signed files.\n      //\n      // This function resolves the main `Promise` in both cases.\n      const checkSignedStatus = async () => {\n        try {\n          const [\n            // eslint-disable-next-line no-unused-vars\n            httpResponse,\n            status,\n          ] = await this.get({ url: statusUrl });\n          lastStatus = status;\n\n          const canBeAutoSigned = status.automated_signing;\n          // The add-on passed validation and all files have been created. There\n          // are many checks for this state because the data will be updated\n          // incrementally by the API server.\n          const signedAndReady =\n            status.valid &&\n            status.active &&\n            status.reviewed &&\n            status.files &&\n            status.files.length > 0;\n          // The add-on is valid but requires a manual review before it can be\n          // signed.\n          const requiresManualReview = status.valid && !canBeAutoSigned;\n\n          if (signedAndReady || requiresManualReview) {\n            this._progressBar.finish();\n            _clearTimeout(abortTimeout);\n\n            if (requiresManualReview) {\n              this.logger.log(oneLine`Your add-on has been submitted for review.\n              It passed validation but could not be automatically signed\n              because this is a listed add-on.`);\n\n              resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'ADDON_NOT_AUTO_SIGNED',\n                errorDetails: null,\n              });\n              return;\n            }\n\n            if (signedAndReady) {\n              // TODO: show some validation warnings if there are any. We should\n              // show things like \"missing update URL in manifest\"\n              const result = await this.downloadSignedFiles(status.files);\n              resolve({ ...result, id: status.guid });\n            }\n          } else {\n            // The add-on has not been fully processed yet.\n            statusCheckTimeout = _setStatusCheckTimeout(\n              checkSignedStatus,\n              this.statusCheckInterval,\n            );\n          }\n        } catch (err) {\n          _clearTimeout(abortTimeout);\n          reject(err);\n        }\n      };\n\n      // This function polls the API until the add-on is processed/validated.\n      // This function only rejects when the add-on is not valid. When the\n      // add-on is valid, we call `checkSignedStatus()`.\n      const checkValidationStatus = async () => {\n        try {\n          const [\n            // eslint-disable-next-line no-unused-vars\n            httpResponse,\n            status,\n          ] = await this.get({ url: statusUrl });\n          lastStatus = status;\n\n          if (status.processed) {\n            this._progressBar.finish();\n            this.logger.log('Validation results:', status.validation_url);\n            // Update pseudo progress preamble for the signing step.\n            this._progressBar.setPreamble('Signing add-on');\n            this._progressBar.animate();\n\n            if (status.valid) {\n              checkSignedStatus();\n            } else {\n              this.logger.log(\n                'Your add-on failed validation and could not be signed',\n              );\n\n              _clearTimeout(abortTimeout);\n\n              resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'VALIDATION_FAILED',\n                errorDetails: status.validation_url,\n              });\n            }\n          } else {\n            // Validation is not completed yet.\n            statusCheckTimeout = _setStatusCheckTimeout(\n              checkValidationStatus,\n              this.statusCheckInterval,\n            );\n          }\n        } catch (err) {\n          _clearTimeout(abortTimeout);\n          reject(err);\n        }\n      };\n\n      // Goooo\n      this._progressBar.animate();\n      checkValidationStatus();\n    });\n  }\n\n  /**\n   * Download the signed files.\n   *\n   * @param {File[]} signedFiles - Array of file objects returned from the API.\n   * @param {{\n   *   createWriteStream?: typeof defaultFs.createWriteStream,\n   *   request?: typeof defaultRequest,\n   *   stdout?: typeof process.stdout\n   * }} options\n   * @returns {Promise<SignResult>}\n   */\n  async downloadSignedFiles(\n    signedFiles,\n    {\n      createWriteStream = defaultFs.createWriteStream,\n      request = this._request,\n      stdout = process.stdout,\n    } = {},\n  ) {\n    /** @type {Promise<string>[]} */\n    const allDownloads = [];\n    /** @type {null | number} */\n    let dataExpected = null;\n    let dataReceived = 0;\n\n    function showProgress() {\n      let progress = '...';\n      if (dataExpected !== null) {\n        const amount = ((dataReceived / dataExpected) * 100).toFixed();\n        // Pad the percentage amount so that the line length is consistent.\n        // This should do something like '  0%', ' 25%', '100%'\n        let padding = '';\n        try {\n          padding = Array(4 - amount.length).join(' ');\n        } catch (e) {\n          // Ignore Invalid array length and such.\n        }\n        progress = `${padding + amount}% `;\n      }\n      stdout.write(`\\rDownloading signed files: ${progress}`);\n    }\n\n    /**\n     * @param {string} fileUrl\n     * @returns {Promise<string>}\n     */\n    const download = (fileUrl) => {\n      return new Promise((resolve, reject) => {\n        // The API will give us a signed file named in a sane way.\n        const fileName = path.join(this.downloadDir, getUrlBasename(fileUrl));\n        const out = createWriteStream(fileName);\n\n        request(\n          this.configureRequest({\n            method: 'GET',\n            url: fileUrl,\n            followRedirect: true,\n          }),\n        )\n          .on('error', reject)\n          .on(\n            'response',\n            /**\n             * @param {Response} response\n             * @returns {void}\n             */\n            (response) => {\n              if (response.statusCode < 200 || response.statusCode >= 300) {\n                throw new Error(\n                  `Got a ${response.statusCode} response ` +\n                    `when downloading ${fileUrl}`,\n                );\n              }\n              const contentLength = response.headers['content-length'];\n              if (contentLength) {\n                if (dataExpected !== null) {\n                  dataExpected += parseInt(contentLength, 10);\n                } else {\n                  dataExpected = parseInt(contentLength, 10);\n                }\n              }\n            },\n          )\n          .on(\n            'data',\n            /**\n             * @param {string} chunk\n             * @returns {void}\n             */\n            (chunk) => {\n              dataReceived += chunk.length;\n              showProgress();\n            },\n          )\n          .pipe(out)\n          .on('error', reject);\n\n        out.on('finish', function () {\n          stdout.write('\\n'); // end the progress output\n          resolve(fileName);\n        });\n      });\n    };\n\n    let foundUnsignedFiles = false;\n    signedFiles.forEach((file) => {\n      if (file.signed) {\n        allDownloads.push(download(file.download_url));\n      } else {\n        this.debug('This file was not signed:', file);\n\n        foundUnsignedFiles = true;\n      }\n    });\n\n    let downloadedFiles;\n    if (allDownloads.length) {\n      if (foundUnsignedFiles) {\n        this.logger.log(oneLine`Some files were not signed. Re-run with\n        --verbose for details.`);\n      }\n\n      showProgress();\n\n      downloadedFiles = await Promise.all(allDownloads);\n    } else {\n      throw new Error(oneLine`The XPI was processed but no signed files were\n      found. Check your manifest and make sure it targets Firefox as an\n      application.`);\n    }\n\n    this.logger.log('Downloaded:');\n    downloadedFiles.forEach((fileName) => {\n      this.logger.log(`    ${fileName.replace(process.cwd(), '.')}`);\n    });\n\n    return {\n      success: true,\n      id: null,\n      downloadedFiles,\n      errorCode: null,\n      errorDetails: null,\n    };\n  }\n\n  /**\n   * Make a GET request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  get(requestConf, options) {\n    return this.request('get', requestConf, options);\n  }\n\n  /**\n   * Make a POST request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  post(requestConf, options) {\n    return this.request('post', requestConf, options);\n  }\n\n  /**\n   * Make a PUT request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  put(requestConf, options) {\n    return this.request('put', requestConf, options);\n  }\n\n  /**\n   * Make a PATCH request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  patch(requestConf, options) {\n    return this.request('patch', requestConf, options);\n  }\n\n  /**\n   * Make a DELETE request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  delete(requestConf, options) {\n    return this.request('delete', requestConf, options);\n  }\n\n  /**\n   * Returns a URL that is guaranteed to be absolute.\n   *\n   * @param {string} urlString - a relative or already absolute URL\n   * @returns {string} url - an absolute URL, prefixed by the API prefix if necessary.\n   */\n  absoluteURL(urlString) {\n    if (!urlString.match(/^http/i)) {\n      return this.apiUrlPrefix + urlString;\n    }\n\n    return urlString;\n  }\n\n  /**\n   * Configures a request with defaults such as authentication headers.\n   *\n   * @param {RequestConfig} config - as accepted by the `request` module\n   * @param {{ jwt?: typeof defaultJwt}} options\n   * @returns {RequestConfig}\n   */\n  configureRequest(config, { jwt = defaultJwt } = {}) {\n    const requestConf = {\n      ...this.requestConfig,\n      ...config,\n    };\n\n    if (!requestConf.url) {\n      throw new Error('request URL was not specified');\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    requestConf.url = this.absoluteURL(String(requestConf.url));\n\n    if (this.proxyServer) {\n      // eslint-disable-next-line no-param-reassign\n      requestConf.proxy = this.proxyServer;\n    }\n\n    const authToken = jwt.sign({ iss: this.apiKey }, this.apiSecret, {\n      algorithm: 'HS256',\n      expiresIn: this.apiJwtExpiresIn,\n    });\n\n    // Make sure the request won't time out before the JWT expires.\n    // This may be useful for slow file uploads.\n    // eslint-disable-next-line no-param-reassign\n    requestConf.timeout = this.apiJwtExpiresIn * 1000 + 500;\n\n    // eslint-disable-next-line no-param-reassign\n    requestConf.headers = {\n      Authorization: `JWT ${authToken}`,\n      Accept: 'application/json',\n      ...requestConf.headers,\n    };\n\n    return requestConf;\n  }\n\n  /**\n   * Make any HTTP request to the addons.mozilla.org API.\n   *\n   * This includes the necessary authorization header.\n   *\n   * The returned promise will be resolved with an array of arguments that\n   * match the arguments sent to the callback as specified in the `request`\n   * module.\n   *\n   * @param {string} httpMethod - HTTP method name.\n   * @param {RequestConfig} config - options accepted by the `request` module\n   * @param {RequestMethodOptions} options\n   * @returns {RequestMethodReturnValue}\n   */\n  async request(httpMethod, config, { throwOnBadResponse = true } = {}) {\n    const method = httpMethod.toLowerCase();\n    const requestConf = this.configureRequest(config);\n\n    let [\n      // eslint-disable-next-line prefer-const\n      httpResponse,\n      body,\n    ] = await new Promise((resolve, reject) => {\n      this.debug(`[API] ${method.toUpperCase()} request:\\n`, requestConf);\n\n      // Get the caller, like request.get(), request.put() ...\n      // @ts-ignore\n      const requestMethod = this._request[method].bind(this._request);\n      // Wrap the request callback in a promise. Here is an example without\n      // promises:\n      //\n      // request.put(requestConf, function(err, httpResponse, body) {\n      //   // promise gets resolved here\n      // })\n      requestMethod(\n        /** @type RequestConfig */\n        requestConf,\n        /**\n         * @param {Error} error\n         * @param {Response} response\n         * @param {string} responseBody\n         */\n        (error, response, responseBody) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve([response, responseBody]);\n        },\n      );\n    });\n\n    if (throwOnBadResponse) {\n      if (httpResponse.statusCode > 299 || httpResponse.statusCode < 200) {\n        throw new Error(\n          `Received bad response from ${this.absoluteURL(\n            String(requestConf.url),\n          )}; ` +\n            `status: ${httpResponse.statusCode}; ` +\n            `response: ${formatResponse(body)}`,\n        );\n      }\n    }\n\n    if (\n      httpResponse.headers &&\n      httpResponse.headers['content-type'] === 'application/json' &&\n      typeof body === 'string'\n    ) {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {\n        this.logger.log('Failed to parse JSON response from server:', e);\n      }\n    }\n\n    this.debug(\n      `[API] ${method.toUpperCase()} response:\\n`,\n      `Status: ${httpResponse.statusCode}\\n`,\n      { headers: httpResponse.headers, response: body },\n    );\n\n    return [httpResponse, body];\n  }\n\n  /**\n   * Output some debugging info if this instance is configured for it.\n   */\n  debug() {\n    if (!this.debugLogging) {\n      return;\n    }\n\n    /**\n     * @param {{ headers: {[key: string]: string} } & {[prop: string]: any}} obj\n     */\n    function redact(obj) {\n      if (typeof obj !== 'object' || !obj) {\n        return obj;\n      }\n      if (obj.headers) {\n        ['Authorization', 'cookie', 'set-cookie'].forEach(function (hdr) {\n          if (obj.headers[hdr]) {\n            // eslint-disable-next-line no-param-reassign\n            obj.headers[hdr] = '<REDACTED>';\n          }\n        });\n      }\n\n      Object.keys(obj).forEach(function (key) {\n        // eslint-disable-next-line no-param-reassign\n        obj[key] = redact(obj[key]);\n      });\n\n      return obj;\n    }\n\n    // TODO: remove the use of `arguments`\n    // eslint-disable-next-line prefer-rest-params\n    const args = Array.prototype.map.call(arguments, function (val) {\n      let newVal = val;\n      if (typeof newVal === 'object') {\n        newVal = deepcopy(newVal);\n        newVal = redact(newVal);\n      }\n      return newVal;\n    });\n    this.logger.log('[sign-addon]', ...args);\n  }\n}\n","/**\n * @typedef {{\n *   isTTY: boolean;\n *   columns: number;\n *   write: (buffer: string) => boolean;\n * }} Stdout\n */\n\n/**\n * A pseudo progress indicator.\n *\n * This is just a silly shell animation that was meant to simulate how lots of\n * tests would be run on an add-on file. It sort of looks like a torrent file\n * randomly getting filled in.\n */\nclass PseudoProgress {\n  /**\n   * @typedef {object} PseudoProgressParams\n   * @property {string=} preamble\n   * @property {typeof clearInterval=} _clearInterval\n   * @property {Stdout=} stdout\n   * @property {typeof setInterval=} _setInterval\n   *\n   * @param {PseudoProgressParams} params\n   */\n  constructor({\n    _clearInterval = clearInterval,\n    _setInterval = setInterval,\n    preamble = '',\n    stdout = process.stdout,\n  } = {}) {\n    this.interval = null;\n    this.motionCounter = 1;\n\n    this.setInterval = _setInterval;\n    this.clearInterval = _clearInterval;\n    this.stdout = stdout;\n\n    /** @type {string[]} */\n    this.bucket = [];\n    /** @type {number[]} */\n    this.emptyBucketPointers = [];\n\n    this.setPreamble(preamble);\n  }\n\n  /**\n   * @param {string} preamble\n   */\n  setPreamble(preamble) {\n    this.preamble = `${preamble} [`;\n    this.addendum = ']';\n\n    let shellWidth = 80;\n    if (this.stdout.isTTY) {\n      shellWidth = Number(this.stdout.columns);\n    }\n\n    this.emptyBucketPointers = [];\n    this.bucket = [];\n\n    const bucketSize = shellWidth - this.preamble.length - this.addendum.length;\n    for (let i = 0; i < bucketSize; i++) {\n      this.bucket.push(' ');\n      this.emptyBucketPointers.push(i);\n    }\n  }\n\n  /**\n   * @typedef {object} AnimateConfig\n   * @property {number} speed\n   *\n   * @param {AnimateConfig=} animateConfig\n   */\n  animate(animateConfig) {\n    const conf = {\n      speed: 100,\n      ...animateConfig,\n    };\n    let bucketIsFull = false;\n    this.interval = this.setInterval(() => {\n      if (bucketIsFull) {\n        this.moveBucket();\n      } else {\n        bucketIsFull = this.randomlyFillBucket();\n      }\n    }, conf.speed);\n  }\n\n  finish() {\n    if (this.interval) {\n      this.clearInterval(this.interval);\n    }\n\n    this.fillBucket();\n    // The bucket has already filled to the terminal width at this point\n    // but for copy/paste purposes, add a new line:\n    this.stdout.write('\\n');\n  }\n\n  randomlyFillBucket() {\n    // randomly fill a bucket (the width of the shell) with dots.\n    const randomIndex = Math.floor(\n      Math.random() * this.emptyBucketPointers.length,\n    );\n    this.bucket[this.emptyBucketPointers[randomIndex]] = '.';\n\n    this.showBucket();\n\n    let isFull = true;\n    /** @type {number[]} */\n    const newPointers = [];\n    this.emptyBucketPointers.forEach((pointer) => {\n      if (this.bucket[pointer] === ' ') {\n        isFull = false;\n        newPointers.push(pointer);\n      }\n    });\n    this.emptyBucketPointers = newPointers;\n\n    return isFull;\n  }\n\n  fillBucket() {\n    // fill the whole bucket with dots to indicate completion.\n    this.bucket = this.bucket.map(function () {\n      return '.';\n    });\n    this.showBucket();\n  }\n\n  moveBucket() {\n    // animate dots moving in a forward motion.\n    for (let i = 0; i < this.bucket.length; i++) {\n      this.bucket[i] = (i - this.motionCounter) % 3 ? ' ' : '.';\n    }\n    this.showBucket();\n\n    this.motionCounter++;\n  }\n\n  showBucket() {\n    this.stdout.write(\n      `\\r${this.preamble}${this.bucket.join('')}${this.addendum}`,\n    );\n  }\n}\n\nexport default PseudoProgress;\n","import { fs } from 'mz';\n\nimport { Client as DefaultAMOClient } from './amo-client';\n\n/** @typedef {import(\"request\").OptionsWithUrl} RequestConfig */\n/** @typedef {import(\"./amo-client\").ClientParams} ClientParams */\n/** @typedef {import(\"./amo-client\").ReleaseChannel} ReleaseChannel */\n\n/**\n * @typedef {object} SignAddonParams\n * @property {string} xpiPath\n * @property {string} id\n * @property {string} version\n * @property {ClientParams['apiKey']} apiKey\n * @property {ClientParams['apiSecret']} apiSecret\n * @property {ClientParams['apiUrlPrefix']=} apiUrlPrefix\n * @property {ClientParams['apiJwtExpiresIn']=} apiJwtExpiresIn\n * @property {ClientParams['debugLogging']=} verbose\n * @property {ReleaseChannel=} channel\n * @property {ClientParams['statusCheckTimeout']=} timeout\n * @property {ClientParams['downloadDir']=} downloadDir\n * @property {ClientParams['proxyServer']=} apiProxy\n * @property {ClientParams['requestConfig']=} apiRequestConfig\n * @property {typeof DefaultAMOClient=} AMOClient\n *\n * @param {SignAddonParams} params\n */\nconst signAddon = async ({\n  // Absolute path to add-on XPI file.\n  xpiPath,\n  // The add-on ID as recognized by AMO. Example: my-addon@jetpack\n  id,\n  // The add-on version number for AMO.\n  version,\n  // Your API key (JWT issuer) from AMO Devhub.\n  apiKey,\n  // Your API secret (JWT secret) from AMO Devhub.\n  apiSecret,\n  // Optional arguments:\n  apiUrlPrefix = 'https://addons.mozilla.org/api/v4',\n  // Number of seconds until the JWT token for the API request expires.\n  // This must match the expiration time that the API server accepts.\n  apiJwtExpiresIn,\n  verbose = false,\n  // The release channel (listed or unlisted).\n  // Ignored for new add-ons, which are always unlisted.\n  // Defaults to most recently used channel.\n  channel,\n  // Number of milliseconds to wait before giving up on a\n  // response from Mozilla's web service.\n  timeout,\n  // Absolute directory to save downloaded files in.\n  downloadDir,\n  // Optional proxy to use for all API requests,\n  // such as \"http://yourproxy:6000\"\n  apiProxy,\n  // Optional object to pass into request() for additional configuration.\n  // Not all properties are guaranteed to be applied.\n  apiRequestConfig,\n  AMOClient = DefaultAMOClient,\n}) => {\n  /**\n   * @param {string} name\n   */\n  function reportEmpty(name) {\n    throw new Error(`required argument was empty: ${name}`);\n  }\n\n  if (!xpiPath) {\n    reportEmpty('xpiPath');\n  }\n\n  if (!version) {\n    reportEmpty('version');\n  }\n\n  if (!apiSecret) {\n    reportEmpty('apiSecret');\n  }\n\n  if (!apiKey) {\n    reportEmpty('apiKey');\n  }\n\n  try {\n    const stats = await fs.stat(xpiPath);\n\n    if (!stats.isFile) {\n      throw new Error(`not a file: ${xpiPath}`);\n    }\n  } catch (statError) {\n    throw new Error(`error with ${xpiPath}: ${statError}`);\n  }\n\n  const client = new AMOClient({\n    apiKey,\n    apiSecret,\n    apiUrlPrefix,\n    apiJwtExpiresIn,\n    downloadDir,\n    debugLogging: verbose,\n    statusCheckTimeout: timeout,\n    proxyServer: apiProxy,\n    requestConfig: apiRequestConfig,\n  });\n\n  return client.sign({\n    xpiPath,\n    guid: id,\n    version,\n    channel,\n  });\n};\n\n/**\n * @param {SignAddonParams} options\n * @param {{\n *   systemProcess?: typeof process,\n *   throwError?: boolean,\n *   logger?: typeof console\n * }} extras\n * @returns {Promise<void>}\n */\nexport const signAddonAndExit = async (\n  options,\n  { systemProcess = process, throwError = false, logger = console },\n) => {\n  try {\n    const result = await signAddon(options);\n    logger.log(result.success ? 'SUCCESS' : 'FAIL');\n    systemProcess.exit(result.success ? 0 : 1);\n  } catch (err) {\n    logger.error('FAIL');\n\n    if (throwError) {\n      throw err;\n    }\n\n    logger.error(err.stack);\n    systemProcess.exit(1);\n  }\n};\n\nexport default { signAddon, signAddonAndExit };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(657);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))"],"sourceRoot":""}